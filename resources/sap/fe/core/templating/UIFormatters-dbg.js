sap.ui.define(["sap/fe/core/converters/MetaModelConverter", "sap/fe/core/helpers/BindingExpression", "sap/fe/core/converters/helpers/BindingHelper", "sap/fe/core/templating/PropertyHelper", "sap/fe/core/templating/DataModelPathHelper"], function (MetaModelConverter, BindingExpression, BindingHelper, PropertyHelper, DataModelPathHelper) {
  "use strict";

  var _exports = {};
  var isPathUpdatable = DataModelPathHelper.isPathUpdatable;
  var isReadOnlyExpression = PropertyHelper.isReadOnlyExpression;
  var isPathExpression = PropertyHelper.isPathExpression;
  var isNonEditableExpression = PropertyHelper.isNonEditableExpression;
  var isKey = PropertyHelper.isKey;
  var isImmutable = PropertyHelper.isImmutable;
  var isDisabledExpression = PropertyHelper.isDisabledExpression;
  var isComputed = PropertyHelper.isComputed;
  var hasValueHelp = PropertyHelper.hasValueHelp;
  var hasSemanticObject = PropertyHelper.hasSemanticObject;
  var getAssociatedCurrencyProperty = PropertyHelper.getAssociatedCurrencyProperty;
  var getAssociatedUnitProperty = PropertyHelper.getAssociatedUnitProperty;
  var UI = BindingHelper.UI;
  var or = BindingExpression.or;
  var not = BindingExpression.not;
  var isConstant = BindingExpression.isConstant;
  var ifElse = BindingExpression.ifElse;
  var equal = BindingExpression.equal;
  var compileBinding = BindingExpression.compileBinding;
  var and = BindingExpression.and;
  var getInvolvedDataModelObjects = MetaModelConverter.getInvolvedDataModelObjects;
  var convertMetaModelContext = MetaModelConverter.convertMetaModelContext;

  /**
   * Create the expression to generate an "editable" boolean value.
   *
   * @param {PropertyPath} oPropertyPath the input property
   * @param {DataModelObjectPath} oDataModelObjectPath the path to this property object
   * @param {boolean} bAsObject whether or not this should be returned as an object or a binding string
   * @returns {string} the binding string
   */
  var getEditableExpression = function (oPropertyPath, oDataModelObjectPath) {
    var bAsObject = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (!oPropertyPath || typeof oPropertyPath === "string") {
      return compileBinding(false);
    }

    var oProperty = isPathExpression(oPropertyPath) && oPropertyPath.$target || oPropertyPath; // Editability depends on the field control expression
    // If the Field control is statically in ReadOnly or Inapplicable (disabled) -> not editable
    // If the property is a key -> not editable except in creation if not computed
    // If the property is computed -> not editable
    // If the property is not updatable -> not editable
    // If the property is immutable -> not editable except in creation
    // If the property has a SemanticObject and no ValueList defined -> not editable
    // If the Field control is a path resolving to ReadOnly or Inapplicable (disabled) (<= 1) -> not editable
    // Else, to be editable you need
    // immutable and key while in the creation row
    // ui/isEditable

    var isPathUpdatableExpression = isPathUpdatable(oDataModelObjectPath, oPropertyPath);
    var editableExpression = ifElse(or(not(isPathUpdatableExpression), isComputed(oProperty), isKey(oProperty), isImmutable(oProperty), hasSemanticObject(oProperty) && !hasValueHelp(oProperty), isNonEditableExpression(oProperty)), ifElse((isImmutable(oProperty) || isKey(oProperty)) && !isComputed(oProperty), and(isPathUpdatableExpression, UI.IsTransientBinding), false), UI.IsEditable);

    if (bAsObject) {
      return editableExpression;
    }

    return compileBinding(editableExpression);
  };
  /**
   * Create the expression to generate an "enabled" boolean value.
   *
   * @param {PropertyPath} oPropertyPath the input property
   * @param {boolean} bAsObject whether or not this should be returned as an object or a binding string
   * @returns {string} the binding string
   */


  _exports.getEditableExpression = getEditableExpression;

  var getEnabledExpression = function (oPropertyPath) {
    var bAsObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (!oPropertyPath || typeof oPropertyPath === "string") {
      return compileBinding(true);
    }

    var oProperty = isPathExpression(oPropertyPath) && oPropertyPath.$target || oPropertyPath; // Enablement depends on the field control expression
    // If the Field control is statically in Inapplicable (disabled) -> not enabled

    var enabledExpression = ifElse(isDisabledExpression(oProperty), false, true);

    if (bAsObject) {
      return enabledExpression;
    }

    return compileBinding(enabledExpression);
  };
  /**
   * Create the expression to generate an "editMode" enum value.
   * @param {PropertyPath} oPropertyPath the input property
   * @param {DataModelObjectPath} oDataModelObjectPath the list of involved data model object to reach that property
   * @param {boolean} bAsObject return this as an expression
   * @returns {BindingExpression<string> | ExpressionOrPrimitive<string>} the binding string or part
   */


  _exports.getEnabledExpression = getEnabledExpression;

  var getEditMode = function (oPropertyPath, oDataModelObjectPath) {
    var bAsObject = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (!oPropertyPath || typeof oPropertyPath === "string") {
      return "Display";
    }

    var oProperty = isPathExpression(oPropertyPath) && oPropertyPath.$target || oPropertyPath; // if the property is not enabled => Disabled
    // if the property is enabled && not editable => ReadOnly
    // if the property is enabled && editable => Editable
    // If there is an associated unit, and it has a field control also use consider the following
    // if the unit field control is readonly -> EditableReadOnly
    // otherwise -> Editable

    var editableExpression = getEditableExpression(oPropertyPath, oDataModelObjectPath, true);
    var enabledExpression = getEnabledExpression(oPropertyPath, true);
    var unitProperty = getAssociatedCurrencyProperty(oProperty) || getAssociatedUnitProperty(oProperty);
    var resultExpression = "Editable";

    if (unitProperty) {
      resultExpression = ifElse(or(isReadOnlyExpression(unitProperty), isComputed(unitProperty)), "EditableReadOnly", "Editable");
    }

    var readOnlyExpression = isReadOnlyExpression(oProperty); // if the property is from a non-updatable entity => Read only mode, previously calculated edit Mode is ignored
    // if the property is from an updatable entity => previously calculated edit Mode expression

    var editModeExpression = ifElse(enabledExpression, ifElse(editableExpression, resultExpression, ifElse(and(!isConstant(readOnlyExpression) && readOnlyExpression, UI.IsEditable), "ReadOnly", "Display")), ifElse(UI.IsEditable, "Disabled", "Display"));

    if (bAsObject) {
      return editModeExpression;
    }

    return compileBinding(editModeExpression);
  };

  _exports.getEditMode = getEditMode;

  var ifUnitEditable = function (oPropertyPath, sEditableValue, sNonEditableValue) {
    if (!oPropertyPath || typeof oPropertyPath === "string") {
      return "Display";
    }

    var oProperty = isPathExpression(oPropertyPath) && oPropertyPath.$target || oPropertyPath;
    var unitProperty = getAssociatedCurrencyProperty(oProperty) || getAssociatedUnitProperty(oProperty);

    if (!unitProperty) {
      return compileBinding(sNonEditableValue);
    }

    var editableExpression = and(not(isReadOnlyExpression(unitProperty)), not(isComputed(unitProperty)));
    return compileBinding(ifElse(editableExpression, sEditableValue, sNonEditableValue));
  };

  _exports.ifUnitEditable = ifUnitEditable;

  var getDisplayMode = function (oPropertyPath, oDataModelObjectPath) {
    var _oProperty$annotation, _oProperty$annotation2, _oTextAnnotation$anno, _oTextAnnotation$anno2, _oEntitySet$entityTyp, _oEntitySet$entityTyp2, _oEntitySet$entityTyp3;

    if (!oPropertyPath || typeof oPropertyPath === "string") {
      return "Value";
    }

    var oProperty = isPathExpression(oPropertyPath) && oPropertyPath.$target || oPropertyPath;
    var oEntitySet = oDataModelObjectPath.targetEntitySet;
    var oTextAnnotation = (_oProperty$annotation = oProperty.annotations) === null || _oProperty$annotation === void 0 ? void 0 : (_oProperty$annotation2 = _oProperty$annotation.Common) === null || _oProperty$annotation2 === void 0 ? void 0 : _oProperty$annotation2.Text;
    var oTextArrangementAnnotation = typeof oTextAnnotation !== "string" && (oTextAnnotation === null || oTextAnnotation === void 0 ? void 0 : (_oTextAnnotation$anno = oTextAnnotation.annotations) === null || _oTextAnnotation$anno === void 0 ? void 0 : (_oTextAnnotation$anno2 = _oTextAnnotation$anno.UI) === null || _oTextAnnotation$anno2 === void 0 ? void 0 : _oTextAnnotation$anno2.TextArrangement) || (oEntitySet === null || oEntitySet === void 0 ? void 0 : (_oEntitySet$entityTyp = oEntitySet.entityType) === null || _oEntitySet$entityTyp === void 0 ? void 0 : (_oEntitySet$entityTyp2 = _oEntitySet$entityTyp.annotations) === null || _oEntitySet$entityTyp2 === void 0 ? void 0 : (_oEntitySet$entityTyp3 = _oEntitySet$entityTyp2.UI) === null || _oEntitySet$entityTyp3 === void 0 ? void 0 : _oEntitySet$entityTyp3.TextArrangement);
    var sDisplayValue = oTextAnnotation ? "DescriptionValue" : "Value";

    if (oTextAnnotation && oTextArrangementAnnotation) {
      if (oTextArrangementAnnotation === "UI.TextArrangementType/TextOnly") {
        sDisplayValue = "Description";
      } else if (oTextArrangementAnnotation === "UI.TextArrangementType/TextLast") {
        sDisplayValue = "ValueDescription";
      } else if (oTextArrangementAnnotation === "UI.TextArrangementType/TextSeparate") {
        sDisplayValue = "Value";
      } else {
        //Default should be TextFirst if there is a Text annotation and neither TextOnly nor TextLast are set
        sDisplayValue = "DescriptionValue";
      }
    }

    return sDisplayValue;
  };

  _exports.getDisplayMode = getDisplayMode;

  var getFieldDisplay = function (oPropertyPath, sTargetDisplayMode, oComputedEditMode) {
    var oProperty = isPathExpression(oPropertyPath) && oPropertyPath.$target || oPropertyPath;
    return hasValueHelp(oProperty) ? compileBinding(sTargetDisplayMode) : compileBinding(ifElse(equal(oComputedEditMode, "Editable"), "Value", sTargetDisplayMode));
  };

  _exports.getFieldDisplay = getFieldDisplay;

  var getAlignmentExpression = function (oComputedEditMode) {
    var sAlignDisplay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Begin";
    var sAlignEdit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "Begin";
    return compileBinding(ifElse(equal(oComputedEditMode, "Display"), sAlignDisplay, sAlignEdit));
  };
  /**
   * Formatter helper to retrieve the converterContext from the metamodel context.
   *
   * @param {Context} oContext the original metamodel context
   * @param {ComputedAnnotationInterface} oInterface the current templating context
   * @returns {object} the converter context representing that object
   */


  _exports.getAlignmentExpression = getAlignmentExpression;

  var getConverterContext = function (oContext, oInterface) {
    if (oInterface && oInterface.context) {
      return convertMetaModelContext(oInterface.context);
    }

    return null;
  };

  getConverterContext.requiresIContext = true;
  /**
   * Formatter helper to retrieve the involved data model object from the metamodel context.
   *
   * @param {Context} oContext the original metamodel context
   * @param {ComputedAnnotationInterface} oInterface the current templating context
   * @returns {object[]} an array of entityset and navproperty involved to get to a specific object in the metamodel
   */

  _exports.getConverterContext = getConverterContext;

  var getDataModelObjectPath = function (oContext, oInterface) {
    if (oInterface && oInterface.context) {
      return getInvolvedDataModelObjects(oInterface.context);
    }

    return null;
  };

  getDataModelObjectPath.requiresIContext = true;
  /**
   * Retrieves the expressionBinding created out of a binding expression.
   *
   * @param {Expression<any>} expression the expression to compile
   * @returns {BindingExpression<string>} the expression binding string
   */

  _exports.getDataModelObjectPath = getDataModelObjectPath;

  var getExpressionBinding = function (expression) {
    return compileBinding(expression);
  };

  _exports.getExpressionBinding = getExpressionBinding;
  return _exports;
}, false);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlVJRm9ybWF0dGVycy50cyJdLCJuYW1lcyI6WyJnZXRFZGl0YWJsZUV4cHJlc3Npb24iLCJvUHJvcGVydHlQYXRoIiwib0RhdGFNb2RlbE9iamVjdFBhdGgiLCJiQXNPYmplY3QiLCJjb21waWxlQmluZGluZyIsIm9Qcm9wZXJ0eSIsImlzUGF0aEV4cHJlc3Npb24iLCIkdGFyZ2V0IiwiaXNQYXRoVXBkYXRhYmxlRXhwcmVzc2lvbiIsImlzUGF0aFVwZGF0YWJsZSIsImVkaXRhYmxlRXhwcmVzc2lvbiIsImlmRWxzZSIsIm9yIiwibm90IiwiaXNDb21wdXRlZCIsImlzS2V5IiwiaXNJbW11dGFibGUiLCJoYXNTZW1hbnRpY09iamVjdCIsImhhc1ZhbHVlSGVscCIsImlzTm9uRWRpdGFibGVFeHByZXNzaW9uIiwiYW5kIiwiVUkiLCJJc1RyYW5zaWVudEJpbmRpbmciLCJJc0VkaXRhYmxlIiwiZ2V0RW5hYmxlZEV4cHJlc3Npb24iLCJlbmFibGVkRXhwcmVzc2lvbiIsImlzRGlzYWJsZWRFeHByZXNzaW9uIiwiZ2V0RWRpdE1vZGUiLCJ1bml0UHJvcGVydHkiLCJnZXRBc3NvY2lhdGVkQ3VycmVuY3lQcm9wZXJ0eSIsImdldEFzc29jaWF0ZWRVbml0UHJvcGVydHkiLCJyZXN1bHRFeHByZXNzaW9uIiwiaXNSZWFkT25seUV4cHJlc3Npb24iLCJyZWFkT25seUV4cHJlc3Npb24iLCJlZGl0TW9kZUV4cHJlc3Npb24iLCJpc0NvbnN0YW50IiwiaWZVbml0RWRpdGFibGUiLCJzRWRpdGFibGVWYWx1ZSIsInNOb25FZGl0YWJsZVZhbHVlIiwiZ2V0RGlzcGxheU1vZGUiLCJvRW50aXR5U2V0IiwidGFyZ2V0RW50aXR5U2V0Iiwib1RleHRBbm5vdGF0aW9uIiwiYW5ub3RhdGlvbnMiLCJDb21tb24iLCJUZXh0Iiwib1RleHRBcnJhbmdlbWVudEFubm90YXRpb24iLCJUZXh0QXJyYW5nZW1lbnQiLCJlbnRpdHlUeXBlIiwic0Rpc3BsYXlWYWx1ZSIsImdldEZpZWxkRGlzcGxheSIsInNUYXJnZXREaXNwbGF5TW9kZSIsIm9Db21wdXRlZEVkaXRNb2RlIiwiZXF1YWwiLCJnZXRBbGlnbm1lbnRFeHByZXNzaW9uIiwic0FsaWduRGlzcGxheSIsInNBbGlnbkVkaXQiLCJnZXRDb252ZXJ0ZXJDb250ZXh0Iiwib0NvbnRleHQiLCJvSW50ZXJmYWNlIiwiY29udGV4dCIsImNvbnZlcnRNZXRhTW9kZWxDb250ZXh0IiwicmVxdWlyZXNJQ29udGV4dCIsImdldERhdGFNb2RlbE9iamVjdFBhdGgiLCJnZXRJbnZvbHZlZERhdGFNb2RlbE9iamVjdHMiLCJnZXRFeHByZXNzaW9uQmluZGluZyIsImV4cHJlc3Npb24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBDQTs7Ozs7Ozs7QUFRTyxNQUFNQSxxQkFBcUIsR0FBRyxVQUNwQ0MsYUFEb0MsRUFFcENDLG9CQUZvQyxFQUkwQjtBQUFBLFFBRDlEQyxTQUM4RCx1RUFEekMsS0FDeUM7O0FBQzlELFFBQUksQ0FBQ0YsYUFBRCxJQUFrQixPQUFPQSxhQUFQLEtBQXlCLFFBQS9DLEVBQXlEO0FBQ3hELGFBQU9HLGNBQWMsQ0FBQyxLQUFELENBQXJCO0FBQ0E7O0FBQ0QsUUFBTUMsU0FBbUIsR0FBSUMsZ0JBQWdCLENBQUNMLGFBQUQsQ0FBaEIsSUFBbUNBLGFBQWEsQ0FBQ00sT0FBbEQsSUFBK0ROLGFBQTNGLENBSjhELENBSzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsUUFBTU8seUJBQXlCLEdBQUdDLGVBQWUsQ0FBQ1Asb0JBQUQsRUFBdUJELGFBQXZCLENBQWpEO0FBQ0EsUUFBTVMsa0JBQWtCLEdBQUdDLE1BQU0sQ0FDaENDLEVBQUUsQ0FDREMsR0FBRyxDQUFDTCx5QkFBRCxDQURGLEVBRURNLFVBQVUsQ0FBQ1QsU0FBRCxDQUZULEVBR0RVLEtBQUssQ0FBQ1YsU0FBRCxDQUhKLEVBSURXLFdBQVcsQ0FBQ1gsU0FBRCxDQUpWLEVB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QzdCLFFBQUlBLFVBQVUsSUFBSUEsVUFBVSxDQUFDQyxPQUE3QixFQUFzQztBQUNyQyxhQUFPSSwyQkFBMkIsQ0FBQ0wsVUFBVSxDQUFDQyxPQUFaLENBQWxDO0FBQ0E7O0FBQ0QsV0FBTyxJQUFQO0FBQ0EsR0FSTTs7QUFTUEcsRUFBQUEsc0JBQXNCLENBQUNELGdCQUF2QixHQUEwQyxJQUExQztBQUVBOzs7Ozs7Ozs7QUFNTyxNQUFNRyxvQkFBb0IsR0FBRyxVQUFTQyxVQUFULEVBQWlFO0FBQ3BHLFdBQU85RCxjQUFjLENBQUM4RCxVQUFELENBQXJCO0FBQ0EsR0FGTSIsInNvdXJjZVJvb3QiOiIuIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29udGV4dCB9IGZyb20gXCJzYXAvdWkvbW9kZWwvb2RhdGEvdjRcIjtcbmltcG9ydCB7IGNvbnZlcnRNZXRhTW9kZWxDb250ZXh0LCBnZXRJbnZvbHZlZERhdGFNb2RlbE9iamVjdHMgfSBmcm9tIFwic2FwL2ZlL2NvcmUvY29udmVydGVycy9NZXRhTW9kZWxDb252ZXJ0ZXJcIjtcbmltcG9ydCB7XG5cdGFuZCxcblx0QmluZGluZ0V4cHJlc3Npb24sXG5cdGNvbXBpbGVCaW5kaW5nLFxuXHRlcXVhbCxcblx0RXhwcmVzc2lvbixcblx0RXhwcmVzc2lvbk9yUHJpbWl0aXZlLFxuXHRpZkVsc2UsXG5cdGlzQ29uc3RhbnQsXG5cdG5vdCxcblx0b3Jcbn0gZnJvbSBcInNhcC9mZS9jb3JlL2hlbHBlcnMvQmluZGluZ0V4cHJlc3Npb25cIjtcbmltcG9ydCB7IFVJIH0gZnJvbSBcInNhcC9mZS9jb3JlL2NvbnZlcnRlcnMvaGVscGVycy9CaW5kaW5nSGVscGVyXCI7XG5pbXBvcnQge1xuXHRnZXRBc3NvY2lhdGVkVW5pdFByb3BlcnR5LFxuXHRnZXRBc3NvY2lhdGVkQ3VycmVuY3lQcm9wZXJ0eSxcblx0aGFzU2VtYW50aWNPYmplY3QsXG5cdGhhc1ZhbHVlSGVscCxcblx0aXNDb21wdXRlZCxcblx0aXNEaXNhYmxlZEV4cHJlc3Npb24sXG5cdGlzSW1tdXRhYmxlLFxuXHRpc0tleSxcblx0aXNOb25FZGl0YWJsZUV4cHJlc3Npb24sXG5cdGlzUGF0aEV4cHJlc3Npb24sXG5cdGlzUmVhZE9ubHlFeHByZXNzaW9uXG59IGZyb20gXCJzYXAvZmUvY29yZS90ZW1wbGF0aW5nL1Byb3BlcnR5SGVscGVyXCI7XG5pbXBvcnQgeyBQcm9wZXJ0eVBhdGggfSBmcm9tIFwiQHNhcC11eC92b2NhYnVsYXJpZXMtdHlwZXNcIjtcbmltcG9ydCB7IFByb3BlcnR5IH0gZnJvbSBcIkBzYXAtdXgvYW5ub3RhdGlvbi1jb252ZXJ0ZXJcIjtcbmltcG9ydCB7IFBhdGhBbm5vdGF0aW9uRXhwcmVzc2lvbiB9IGZyb20gXCJAc2FwLXV4L3ZvY2FidWxhcmllcy10eXBlcy90eXBlcy9FZG1cIjtcbmltcG9ydCB7IERhdGFNb2RlbE9iamVjdFBhdGgsIGlzUGF0aFVwZGF0YWJsZSB9IGZyb20gXCJzYXAvZmUvY29yZS90ZW1wbGF0aW5nL0RhdGFNb2RlbFBhdGhIZWxwZXJcIjtcblxuZXhwb3J0IHR5cGUgUHJvcGVydHlPclBhdGg8UD4gPSBzdHJpbmcgfCBQIHwgUGF0aEFubm90YXRpb25FeHByZXNzaW9uPFA+O1xuZXhwb3J0IHR5cGUgTWV0YU1vZGVsQ29udGV4dCA9IHtcblx0JGtpbmQ6IHN0cmluZztcbn07XG5leHBvcnQgdHlwZSBDb21wdXRlZEFubm90YXRpb25JbnRlcmZhY2UgPSB7XG5cdGNvbnRleHQ6IENvbnRleHQ7XG5cdGFyZ3VtZW50czogYW55W107XG5cdCQkdmFsdWVBc1Byb21pc2U6IGJvb2xlYW47XG59O1xuLyoqXG4gKiBDcmVhdGUgdGhlIGV4cHJlc3Npb24gdG8gZ2VuZXJhdGUgYW4gXCJlZGl0YWJsZVwiIGJvb2xlYW4gdmFsdWUuXG4gKlxuICogQHBhcmFtIHtQcm9wZXJ0eVBhdGh9IG9Qcm9wZXJ0eVBhdGggdGhlIGlucHV0IHByb3BlcnR5XG4gKiBAcGFyYW0ge0RhdGFNb2RlbE9iamVjdFBhdGh9IG9EYXRhTW9kZWxPYmplY3RQYXRoIHRoZSBwYXRoIHRvIHRoaXMgcHJvcGVydHkgb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJBc09iamVjdCB3aGV0aGVyIG9yIG5vdCB0aGlzIHNob3VsZCBiZSByZXR1cm5lZCBhcyBhbiBvYmplY3Qgb3IgYSBiaW5kaW5nIHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIGJpbmRpbmcgc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRFZGl0YWJsZUV4cHJlc3Npb24gPSBmdW5jdGlvbihcblx0b1Byb3BlcnR5UGF0aDogUHJvcGVydHlPclBhdGg8UHJvcGVydHk+LFxuXHRvRGF0YU1vZGVsT2JqZWN0UGF0aD86IERhdGFNb2RlbE9iamVjdFBhdGgsXG5cdGJBc09iamVjdDogYm9vbGVhbiA9IGZhbHNlXG4pOiBCaW5kaW5nRXhwcmVzc2lvbjxib29sZWFuPiB8IEV4cHJlc3Npb25PclByaW1pdGl2ZTxib29sZWFuPiB7XG5cdGlmICghb1Byb3BlcnR5UGF0aCB8fCB0eXBlb2Ygb1Byb3BlcnR5UGF0aCA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHJldHVybiBjb21waWxlQmluZGluZyhmYWxzZSk7XG5cdH1cblx0Y29uc3Qgb1Byb3BlcnR5OiBQcm9wZXJ0eSA9IChpc1BhdGhFeHByZXNzaW9uKG9Qcm9wZXJ0eVBhdGgpICYmIG9Qcm9wZXJ0eVBhdGguJHRhcmdldCkgfHwgKG9Qcm9wZXJ0eVBhdGggYXMgUHJvcGVydHkpO1xuXHQvLyBFZGl0YWJpbGl0eSBkZXBlbmRzIG9uIHRoZSBmaWVsZCBjb250cm9sIGV4cHJlc3Npb25cblx0Ly8gSWYgdGhlIEZpZWxkIGNvbnRyb2wgaXMgc3RhdGljYWxseSBpbiBSZWFkT25seSBvciBJbmFwcGxpY2FibGUgKGRpc2FibGVkKSAtPiBub3QgZWRpdGFibGVcblx0Ly8gSWYgdGhlIHByb3BlcnR5IGlzIGEga2V5IC0+IG5vdCBlZGl0YWJsZSBleGNlcHQgaW4gY3JlYXRpb24gaWYgbm90IGNvbXB1dGVkXG5cdC8vIElmIHRoZSBwcm9wZXJ0eSBpcyBjb21wdXRlZCAtPiBub3QgZWRpdGFibGVcblx0Ly8gSWYgdGhlIHByb3BlcnR5IGlzIG5vdCB1cGRhdGFibGUgLT4gbm90IGVkaXRhYmxlXG5cdC8vIElmIHRoZSBwcm9wZXJ0eSBpcyBpbW11dGFibGUgLT4gbm90IGVkaXRhYmxlIGV4Y2VwdCBpbiBjcmVhdGlvblxuXHQvLyBJZiB0aGUgcHJvcGVydHkgaGFzIGEgU2VtYW50aWNPYmplY3QgYW5kIG5vIFZhbHVlTGlzdCBkZWZpbmVkIC0+IG5vdCBlZGl0YWJsZVxuXHQvLyBJZiB0aGUgRmllbGQgY29udHJvbCBpcyBhIHBhdGggcmVzb2x2aW5nIHRvIFJlYWRPbmx5IG9yIEluYXBwbGljYWJsZSAoZGlzYWJsZWQpICg8PSAxKSAtPiBub3QgZWRpdGFibGVcblx0Ly8gRWxzZSwgdG8gYmUgZWRpdGFibGUgeW91IG5lZWRcblx0Ly8gaW1tdXRhYmxlIGFuZCBrZXkgd2hpbGUgaW4gdGhlIGNyZWF0aW9uIHJvd1xuXHQvLyB1aS9pc0VkaXRhYmxlXG5cdGNvbnN0IGlzUGF0aFVwZGF0YWJsZUV4cHJlc3Npb24gPSBpc1BhdGhVcGRhdGFibGUob0RhdGFNb2RlbE9iamVjdFBhdGgsIG9Qcm9wZXJ0eVBhdGgpO1xuXHRjb25zdCBlZGl0YWJsZUV4cHJlc3Npb24gPSBpZkVsc2UoXG5cdFx0b3IoXG5cdFx0XHRub3QoaXNQYXRoVXBkYXRhYmxlRXhwcmVzc2lvbiksXG5cdFx0XHRpc0NvbXB1dGVkKG9Qcm9wZXJ0eSksXG5cdFx0XHRpc0tleShvUHJvcGVydHkpLFxuXHRcdFx0aXNJbW11dGFibGUob1Byb3BlcnR5KSxcblx0XHRcdGhhc1NlbWFudGljT2JqZWN0KG9Qcm9wZXJ0eSkgJiYgIWhhc1ZhbHVlSGVscChvUHJvcGVydHkpLFxuXHRcdFx0aXNOb25FZGl0YWJsZUV4cHJlc3Npb24ob1Byb3BlcnR5KVxuXHRcdCksXG5cdFx0aWZFbHNlKFxuXHRcdFx0KGlzSW1tdXRhYmxlKG9Qcm9wZXJ0eSkgfHwgaXNLZXkob1Byb3BlcnR5KSkgJiYgIWlzQ29tcHV0ZWQob1Byb3BlcnR5KSxcblx0XHRcdGFuZChpc1BhdGhVcGRhdGFibGVFeHByZXNzaW9uLCBVSS5Jc1RyYW5zaWVudEJpbmRpbmcpLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLFxuXHRcdFVJLklzRWRpdGFibGVcblx0KTtcblx0aWYgKGJBc09iamVjdCkge1xuXHRcdHJldHVybiBlZGl0YWJsZUV4cHJlc3Npb247XG5cdH1cblx0cmV0dXJuIGNvbXBpbGVCaW5kaW5nKGVkaXRhYmxlRXhwcmVzc2lvbik7XG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgZXhwcmVzc2lvbiB0byBnZW5lcmF0ZSBhbiBcImVuYWJsZWRcIiBib29sZWFuIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7UHJvcGVydHlQYXRofSBvUHJvcGVydHlQYXRoIHRoZSBpbnB1dCBwcm9wZXJ0eVxuICogQHBhcmFtIHtib29sZWFufSBiQXNPYmplY3Qgd2hldGhlciBvciBub3QgdGhpcyBzaG91bGQgYmUgcmV0dXJuZWQgYXMgYW4gb2JqZWN0IG9yIGEgYmluZGluZyBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBiaW5kaW5nIHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgZ2V0RW5hYmxlZEV4cHJlc3Npb24gPSBmdW5jdGlvbihcblx0b1Byb3BlcnR5UGF0aDogUHJvcGVydHlPclBhdGg8UHJvcGVydHk+LFxuXHRiQXNPYmplY3Q6IGJvb2xlYW4gPSBmYWxzZVxuKTogQmluZGluZ0V4cHJlc3Npb248Ym9vbGVhbj4gfCBFeHByZXNzaW9uT3JQcmltaXRpdmU8Ym9vbGVhbj4ge1xuXHRpZiAoIW9Qcm9wZXJ0eVBhdGggfHwgdHlwZW9mIG9Qcm9wZXJ0eVBhdGggPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gY29tcGlsZUJpbmRpbmcodHJ1ZSk7XG5cdH1cblx0Y29uc3Qgb1Byb3BlcnR5ID0gKGlzUGF0aEV4cHJlc3Npb24ob1Byb3BlcnR5UGF0aCkgJiYgb1Byb3BlcnR5UGF0aC4kdGFyZ2V0KSB8fCAob1Byb3BlcnR5UGF0aCBhcyBQcm9wZXJ0eSk7XG5cdC8vIEVuYWJsZW1lbnQgZGVwZW5kcyBvbiB0aGUgZmllbGQgY29udHJvbCBleHByZXNzaW9uXG5cdC8vIElmIHRoZSBGaWVsZCBjb250cm9sIGlzIHN0YXRpY2FsbHkgaW4gSW5hcHBsaWNhYmxlIChkaXNhYmxlZCkgLT4gbm90IGVuYWJsZWRcblx0Y29uc3QgZW5hYmxlZEV4cHJlc3Npb24gPSBpZkVsc2UoaXNEaXNhYmxlZEV4cHJlc3Npb24ob1Byb3BlcnR5KSwgZmFsc2UsIHRydWUpO1xuXHRpZiAoYkFzT2JqZWN0KSB7XG5cdFx0cmV0dXJuIGVuYWJsZWRFeHByZXNzaW9uO1xuXHR9XG5cdHJldHVybiBjb21waWxlQmluZGluZyhlbmFibGVkRXhwcmVzc2lvbik7XG59O1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgZXhwcmVzc2lvbiB0byBnZW5lcmF0ZSBhbiBcImVkaXRNb2RlXCIgZW51bSB2YWx1ZS5cbiAqIEBwYXJhbSB7UHJvcGVydHlQYXRofSBvUHJvcGVydHlQYXRoIHRoZSBpbnB1dCBwcm9wZXJ0eVxuICogQHBhcmFtIHtEYXRhTW9kZWxPYmplY3RQYXRofSBvRGF0YU1vZGVsT2JqZWN0UGF0aCB0aGUgbGlzdCBvZiBpbnZvbHZlZCBkYXRhIG1vZGVsIG9iamVjdCB0byByZWFjaCB0aGF0IHByb3BlcnR5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJBc09iamVjdCByZXR1cm4gdGhpcyBhcyBhbiBleHByZXNzaW9uXG4gKiBAcmV0dXJucyB7QmluZGluZ0V4cHJlc3Npb248c3RyaW5nPiB8IEV4cHJlc3Npb25PclByaW1pdGl2ZTxzdHJpbmc+fSB0aGUgYmluZGluZyBzdHJpbmcgb3IgcGFydFxuICovXG5leHBvcnQgY29uc3QgZ2V0RWRpdE1vZGUgPSBmdW5jdGlvbihcblx0b1Byb3BlcnR5UGF0aDogUHJvcGVydHlPclBhdGg8UHJvcGVydHk+LFxuXHRvRGF0YU1vZGVsT2JqZWN0UGF0aDogRGF0YU1vZGVsT2JqZWN0UGF0aCxcblx0YkFzT2JqZWN0OiBib29sZWFuID0gZmFsc2Vcbik6IEJpbmRpbmdFeHByZXNzaW9uPHN0cmluZz4gfCBFeHByZXNzaW9uT3JQcmltaXRpdmU8c3RyaW5nPiB7XG5cdGlmICghb1Byb3BlcnR5UGF0aCB8fCB0eXBlb2Ygb1Byb3BlcnR5UGF0aCA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHJldHVybiBcIkRpc3BsYXlcIjtcblx0fVxuXHRjb25zdCBvUHJvcGVydHkgPSAoaXNQYXRoRXhwcmVzc2lvbihvUHJvcGVydHlQYXRoKSAmJiBvUHJvcGVydHlQYXRoLiR0YXJnZXQpIHx8IChvUHJvcGVydHlQYXRoIGFzIFByb3BlcnR5KTtcblx0Ly8gaWYgdGhlIHByb3BlcnR5IGlzIG5vdCBlbmFibGVkID0+IERpc2FibGVkXG5cdC8vIGlmIHRoZSBwcm9wZXJ0eSBpcyBlbmFibGVkICYmIG5vdCBlZGl0YWJsZSA9PiBSZWFkT25seVxuXHQvLyBpZiB0aGUgcHJvcGVydHkgaXMgZW5hYmxlZCAmJiBlZGl0YWJsZSA9PiBFZGl0YWJsZVxuXHQvLyBJZiB0aGVyZSBpcyBhbiBhc3NvY2lhdGVkIHVuaXQsIGFuZCBpdCBoYXMgYSBmaWVsZCBjb250cm9sIGFsc28gdXNlIGNvbnNpZGVyIHRoZSBmb2xsb3dpbmdcblx0Ly8gaWYgdGhlIHVuaXQgZmllbGQgY29udHJvbCBpcyByZWFkb25seSAtPiBFZGl0YWJsZVJlYWRPbmx5XG5cdC8vIG90aGVyd2lzZSAtPiBFZGl0YWJsZVxuXHRjb25zdCBlZGl0YWJsZUV4cHJlc3Npb24gPSBnZXRFZGl0YWJsZUV4cHJlc3Npb24ob1Byb3BlcnR5UGF0aCwgb0RhdGFNb2RlbE9iamVjdFBhdGgsIHRydWUpIGFzIEV4cHJlc3Npb25PclByaW1pdGl2ZTxib29sZWFuPjtcblx0Y29uc3QgZW5hYmxlZEV4cHJlc3Npb24gPSBnZXRFbmFibGVkRXhwcmVzc2lvbihvUHJvcGVydHlQYXRoLCB0cnVlKSBhcyBFeHByZXNzaW9uT3JQcmltaXRpdmU8Ym9vbGVhbj47XG5cdGNvbnN0IHVuaXRQcm9wZXJ0eSA9IGdldEFzc29jaWF0ZWRDdXJyZW5jeVByb3BlcnR5KG9Qcm9wZXJ0eSkgfHwgZ2V0QXNzb2NpYXRlZFVuaXRQcm9wZXJ0eShvUHJvcGVydHkpO1xuXHRsZXQgcmVzdWx0RXhwcmVzc2lvbjogRXhwcmVzc2lvbk9yUHJpbWl0aXZlPHN0cmluZz4gPSBcIkVkaXRhYmxlXCI7XG5cdGlmICh1bml0UHJvcGVydHkpIHtcblx0XHRyZXN1bHRFeHByZXNzaW9uID0gaWZFbHNlKG9yKGlzUmVhZE9ubHlFeHByZXNzaW9uKHVuaXRQcm9wZXJ0eSksIGlzQ29tcHV0ZWQodW5pdFByb3BlcnR5KSksIFwiRWRpdGFibGVSZWFkT25seVwiLCBcIkVkaXRhYmxlXCIpO1xuXHR9XG5cdGNvbnN0IHJlYWRPbmx5RXhwcmVzc2lvbiA9IGlzUmVhZE9ubHlFeHByZXNzaW9uKG9Qcm9wZXJ0eSk7XG5cblx0Ly8gaWYgdGhlIHByb3BlcnR5IGlzIGZyb20gYSBub24tdXBkYXRhYmxlIGVudGl0eSA9PiBSZWFkIG9ubHkgbW9kZSwgcHJldmlvdXNseSBjYWxjdWxhdGVkIGVkaXQgTW9kZSBpcyBpZ25vcmVkXG5cdC8vIGlmIHRoZSBwcm9wZXJ0eSBpcyBmcm9tIGFuIHVwZGF0YWJsZSBlbnRpdHkgPT4gcHJldmlvdXNseSBjYWxjdWxhdGVkIGVkaXQgTW9kZSBleHByZXNzaW9uXG5cdGNvbnN0IGVkaXRNb2RlRXhwcmVzc2lvbiA9IGlmRWxzZShcblx0XHRlbmFibGVkRXhwcmVzc2lvbixcblx0XHRpZkVsc2UoXG5cdFx0XHRlZGl0YWJsZUV4cHJlc3Npb24sXG5cdFx0XHRyZXN1bHRFeHByZXNzaW9uLFxuXHRcdFx0aWZFbHNlKGFuZCghaXNDb25zdGFudChyZWFkT25seUV4cHJlc3Npb24pICYmIHJlYWRPbmx5RXhwcmVzc2lvbiwgVUkuSXNFZGl0YWJsZSksIFwiUmVhZE9ubHlcIiwgXCJEaXNwbGF5XCIpXG5cdFx0KSxcblx0XHRpZkVsc2UoVUkuSXNFZGl0YWJsZSwgXCJEaXNhYmxlZFwiLCBcIkRpc3BsYXlcIilcblx0KTtcblx0aWYgKGJBc09iamVjdCkge1xuXHRcdHJldHVybiBlZGl0TW9kZUV4cHJlc3Npb247XG5cdH1cblx0cmV0dXJuIGNvbXBpbGVCaW5kaW5nKGVkaXRNb2RlRXhwcmVzc2lvbik7XG59O1xuXG5leHBvcnQgY29uc3QgaWZVbml0RWRpdGFibGUgPSBmdW5jdGlvbihcblx0b1Byb3BlcnR5UGF0aDogUHJvcGVydHlPclBhdGg8UHJvcGVydHk+LFxuXHRzRWRpdGFibGVWYWx1ZTogRXhwcmVzc2lvbk9yUHJpbWl0aXZlPHN0cmluZz4sXG5cdHNOb25FZGl0YWJsZVZhbHVlOiBFeHByZXNzaW9uT3JQcmltaXRpdmU8c3RyaW5nPlxuKTogQmluZGluZ0V4cHJlc3Npb248c3RyaW5nPiB7XG5cdGlmICghb1Byb3BlcnR5UGF0aCB8fCB0eXBlb2Ygb1Byb3BlcnR5UGF0aCA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHJldHVybiBcIkRpc3BsYXlcIjtcblx0fVxuXHRjb25zdCBvUHJvcGVydHkgPSAoaXNQYXRoRXhwcmVzc2lvbihvUHJvcGVydHlQYXRoKSAmJiBvUHJvcGVydHlQYXRoLiR0YXJnZXQpIHx8IChvUHJvcGVydHlQYXRoIGFzIFByb3BlcnR5KTtcblx0Y29uc3QgdW5pdFByb3BlcnR5ID0gZ2V0QXNzb2NpYXRlZEN1cnJlbmN5UHJvcGVydHkob1Byb3BlcnR5KSB8fCBnZXRBc3NvY2lhdGVkVW5pdFByb3BlcnR5KG9Qcm9wZXJ0eSk7XG5cdGlmICghdW5pdFByb3BlcnR5KSB7XG5cdFx0cmV0dXJuIGNvbXBpbGVCaW5kaW5nKHNOb25FZGl0YWJsZVZhbHVlKTtcblx0fVxuXHRjb25zdCBlZGl0YWJsZUV4cHJlc3Npb24gPSBhbmQobm90KGlzUmVhZE9ubHlFeHByZXNzaW9uKHVuaXRQcm9wZXJ0eSkpLCBub3QoaXNDb21wdXRlZCh1bml0UHJvcGVydHkpKSk7XG5cdHJldHVybiBjb21waWxlQmluZGluZyhpZkVsc2UoZWRpdGFibGVFeHByZXNzaW9uLCBzRWRpdGFibGVWYWx1ZSwgc05vbkVkaXRhYmxlVmFsdWUpKTtcbn07XG5cbnR5cGUgRGlzcGxheU1vZGUgPSBcIlZhbHVlXCIgfCBcIkRlc2NyaXB0aW9uXCIgfCBcIkRlc2NyaXB0aW9uVmFsdWVcIiB8IFwiVmFsdWVEZXNjcmlwdGlvblwiO1xuZXhwb3J0IGNvbnN0IGdldERpc3BsYXlNb2RlID0gZnVuY3Rpb24ob1Byb3BlcnR5UGF0aDogUHJvcGVydHlPclBhdGg8UHJvcGVydHk+LCBvRGF0YU1vZGVsT2JqZWN0UGF0aDogRGF0YU1vZGVsT2JqZWN0UGF0aCk6IERpc3BsYXlNb2RlIHtcblx0aWYgKCFvUHJvcGVydHlQYXRoIHx8IHR5cGVvZiBvUHJvcGVydHlQYXRoID09PSBcInN0cmluZ1wiKSB7XG5cdFx0cmV0dXJuIFwiVmFsdWVcIjtcblx0fVxuXHRjb25zdCBvUHJvcGVydHkgPSAoaXNQYXRoRXhwcmVzc2lvbihvUHJvcGVydHlQYXRoKSAmJiBvUHJvcGVydHlQYXRoLiR0YXJnZXQpIHx8IChvUHJvcGVydHlQYXRoIGFzIFByb3BlcnR5KTtcblx0Y29uc3Qgb0VudGl0eVNldCA9IG9EYXRhTW9kZWxPYmplY3RQYXRoLnRhcmdldEVudGl0eVNldDtcblx0Y29uc3Qgb1RleHRBbm5vdGF0aW9uID0gb1Byb3BlcnR5LmFubm90YXRpb25zPy5Db21tb24/LlRleHQ7XG5cdGNvbnN0IG9UZXh0QXJyYW5nZW1lbnRBbm5vdGF0aW9uID1cblx0XHQodHlwZW9mIG9UZXh0QW5ub3RhdGlvbiAhPT0gXCJzdHJpbmdcIiAmJiBvVGV4dEFubm90YXRpb24/LmFubm90YXRpb25zPy5VST8uVGV4dEFycmFuZ2VtZW50KSB8fFxuXHRcdG9FbnRpdHlTZXQ/LmVudGl0eVR5cGU/LmFubm90YXRpb25zPy5VST8uVGV4dEFycmFuZ2VtZW50O1xuXG5cdGxldCBzRGlzcGxheVZhbHVlID0gb1RleHRBbm5vdGF0aW9uID8gXCJEZXNjcmlwdGlvblZhbHVlXCIgOiBcIlZhbHVlXCI7XG5cdGlmIChvVGV4dEFubm90YXRpb24gJiYgb1RleHRBcnJhbmdlbWVudEFubm90YXRpb24pIHtcblx0XHRpZiAob1RleHRBcnJhbmdlbWVudEFubm90YXRpb24gPT09IFwiVUkuVGV4dEFycmFuZ2VtZW50VHlwZS9UZXh0T25seVwiKSB7XG5cdFx0XHRzRGlzcGxheVZhbHVlID0gXCJEZXNjcmlwdGlvblwiO1xuXHRcdH0gZWxzZSBpZiAob1RleHRBcnJhbmdlbWVudEFubm90YXRpb24gPT09IFwiVUkuVGV4dEFycmFuZ2VtZW50VHlwZS9UZXh0TGFzdFwiKSB7XG5cdFx0XHRzRGlzcGxheVZhbHVlID0gXCJWYWx1ZURlc2NyaXB0aW9uXCI7XG5cdFx0fSBlbHNlIGlmIChvVGV4dEFycmFuZ2VtZW50QW5ub3RhdGlvbiA9PT0gXCJVSS5UZXh0QXJyYW5nZW1lbnRUeXBlL1RleHRTZXBhcmF0ZVwiKSB7XG5cdFx0XHRzRGlzcGxheVZhbHVlID0gXCJWYWx1ZVwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvL0RlZmF1bHQgc2hvdWxkIGJlIFRleHRGaXJzdCBpZiB0aGVyZSBpcyBhIFRleHQgYW5ub3RhdGlvbiBhbmQgbmVpdGhlciBUZXh0T25seSBub3IgVGV4dExhc3QgYXJlIHNldFxuXHRcdFx0c0Rpc3BsYXlWYWx1ZSA9IFwiRGVzY3JpcHRpb25WYWx1ZVwiO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gc0Rpc3BsYXlWYWx1ZSBhcyBEaXNwbGF5TW9kZTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRGaWVsZERpc3BsYXkgPSBmdW5jdGlvbihcblx0b1Byb3BlcnR5UGF0aDogUHJvcGVydHlPclBhdGg8UHJvcGVydHk+LFxuXHRzVGFyZ2V0RGlzcGxheU1vZGU6IHN0cmluZyxcblx0b0NvbXB1dGVkRWRpdE1vZGU6IEV4cHJlc3Npb25PclByaW1pdGl2ZTxzdHJpbmc+XG4pOiBCaW5kaW5nRXhwcmVzc2lvbjxzdHJpbmc+IHtcblx0Y29uc3Qgb1Byb3BlcnR5ID0gKGlzUGF0aEV4cHJlc3Npb24ob1Byb3BlcnR5UGF0aCkgJiYgb1Byb3BlcnR5UGF0aC4kdGFyZ2V0KSB8fCAob1Byb3BlcnR5UGF0aCBhcyBQcm9wZXJ0eSk7XG5cblx0cmV0dXJuIGhhc1ZhbHVlSGVscChvUHJvcGVydHkpXG5cdFx0PyBjb21waWxlQmluZGluZyhzVGFyZ2V0RGlzcGxheU1vZGUpXG5cdFx0OiBjb21waWxlQmluZGluZyhpZkVsc2UoZXF1YWwob0NvbXB1dGVkRWRpdE1vZGUsIFwiRWRpdGFibGVcIiksIFwiVmFsdWVcIiwgc1RhcmdldERpc3BsYXlNb2RlKSk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QWxpZ25tZW50RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKFxuXHRvQ29tcHV0ZWRFZGl0TW9kZTogRXhwcmVzc2lvbjxzdHJpbmc+LFxuXHRzQWxpZ25EaXNwbGF5OiBzdHJpbmcgPSBcIkJlZ2luXCIsXG5cdHNBbGlnbkVkaXQ6IHN0cmluZyA9IFwiQmVnaW5cIlxuKTogQmluZGluZ0V4cHJlc3Npb248c3RyaW5nPiB8IEV4cHJlc3Npb248c3RyaW5nPiB7XG5cdHJldHVybiBjb21waWxlQmluZGluZyhpZkVsc2UoZXF1YWwob0NvbXB1dGVkRWRpdE1vZGUsIFwiRGlzcGxheVwiKSwgc0FsaWduRGlzcGxheSwgc0FsaWduRWRpdCkpO1xufTtcblxuLyoqXG4gKiBGb3JtYXR0ZXIgaGVscGVyIHRvIHJldHJpZXZlIHRoZSBjb252ZXJ0ZXJDb250ZXh0IGZyb20gdGhlIG1ldGFtb2RlbCBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7Q29udGV4dH0gb0NvbnRleHQgdGhlIG9yaWdpbmFsIG1ldGFtb2RlbCBjb250ZXh0XG4gKiBAcGFyYW0ge0NvbXB1dGVkQW5ub3RhdGlvbkludGVyZmFjZX0gb0ludGVyZmFjZSB0aGUgY3VycmVudCB0ZW1wbGF0aW5nIGNvbnRleHRcbiAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSBjb252ZXJ0ZXIgY29udGV4dCByZXByZXNlbnRpbmcgdGhhdCBvYmplY3RcbiAqL1xuZXhwb3J0IGNvbnN0IGdldENvbnZlcnRlckNvbnRleHQgPSBmdW5jdGlvbihvQ29udGV4dDogTWV0YU1vZGVsQ29udGV4dCwgb0ludGVyZmFjZTogQ29tcHV0ZWRBbm5vdGF0aW9uSW50ZXJmYWNlKTogb2JqZWN0IHwgbnVsbCB7XG5cdGlmIChvSW50ZXJmYWNlICYmIG9JbnRlcmZhY2UuY29udGV4dCkge1xuXHRcdHJldHVybiBjb252ZXJ0TWV0YU1vZGVsQ29udGV4dChvSW50ZXJmYWNlLmNvbnRleHQpO1xuXHR9XG5cdHJldHVybiBudWxsO1xufTtcbmdldENvbnZlcnRlckNvbnRleHQucmVxdWlyZXNJQ29udGV4dCA9IHRydWU7XG5cbi8qKlxuICogRm9ybWF0dGVyIGhlbHBlciB0byByZXRyaWV2ZSB0aGUgaW52b2x2ZWQgZGF0YSBtb2RlbCBvYmplY3QgZnJvbSB0aGUgbWV0YW1vZGVsIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHtDb250ZXh0fSBvQ29udGV4dCB0aGUgb3JpZ2luYWwgbWV0YW1vZGVsIGNvbnRleHRcbiAqIEBwYXJhbSB7Q29tcHV0ZWRBbm5vdGF0aW9uSW50ZXJmYWNlfSBvSW50ZXJmYWNlIHRoZSBjdXJyZW50IHRlbXBsYXRpbmcgY29udGV4dFxuICogQHJldHVybnMge29iamVjdFtdfSBhbiBhcnJheSBvZiBlbnRpdHlzZXQgYW5kIG5hdnByb3BlcnR5IGludm9sdmVkIHRvIGdldCB0byBhIHNwZWNpZmljIG9iamVjdCBpbiB0aGUgbWV0YW1vZGVsXG4gKi9cbmV4cG9ydCBjb25zdCBnZXREYXRhTW9kZWxPYmplY3RQYXRoID0gZnVuY3Rpb24oXG5cdG9Db250ZXh0OiBNZXRhTW9kZWxDb250ZXh0LFxuXHRvSW50ZXJmYWNlOiBDb21wdXRlZEFubm90YXRpb25JbnRlcmZhY2Vcbik6IERhdGFNb2RlbE9iamVjdFBhdGggfCBudWxsIHtcblx0aWYgKG9JbnRlcmZhY2UgJiYgb0ludGVyZmFjZS5jb250ZXh0KSB7XG5cdFx0cmV0dXJuIGdldEludm9sdmVkRGF0YU1vZGVsT2JqZWN0cyhvSW50ZXJmYWNlLmNvbnRleHQpO1xuXHR9XG5cdHJldHVybiBudWxsO1xufTtcbmdldERhdGFNb2RlbE9iamVjdFBhdGgucmVxdWlyZXNJQ29udGV4dCA9IHRydWU7XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBleHByZXNzaW9uQmluZGluZyBjcmVhdGVkIG91dCBvZiBhIGJpbmRpbmcgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0ge0V4cHJlc3Npb248YW55Pn0gZXhwcmVzc2lvbiB0aGUgZXhwcmVzc2lvbiB0byBjb21waWxlXG4gKiBAcmV0dXJucyB7QmluZGluZ0V4cHJlc3Npb248c3RyaW5nPn0gdGhlIGV4cHJlc3Npb24gYmluZGluZyBzdHJpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEV4cHJlc3Npb25CaW5kaW5nID0gZnVuY3Rpb24oZXhwcmVzc2lvbjogRXhwcmVzc2lvbjxhbnk+KTogQmluZGluZ0V4cHJlc3Npb248c3RyaW5nPiB7XG5cdHJldHVybiBjb21waWxlQmluZGluZyhleHByZXNzaW9uKTtcbn07XG4iXX0=